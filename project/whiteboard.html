<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Whiteboard</title>
  <link rel="icon" type="image/png" href="panda.png">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      display: flex;
      transition: background 0.3s ease;
    }

    #toolbar {
      width: 220px;
      background: linear-gradient(180deg, #7e57c2, #81d4fa);
      padding: 20px;
      box-shadow: 2px 0 5px rgba(0,0,0,0.2);
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 10;
    }

    #toolbar h2 {
      color: white;
      text-align: center;
      margin-bottom: 15px;
    }

    #toolbar button, #toolbar select, #toolbar input {
      padding: 8px;
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
    }

    #toolbar button {
      background-color: white;
      color: #333;
    }

    #toolbar select, #toolbar input {
      width: 100%;
    }

    #board {
      flex: 1;
      display: block;
      background-color: white;
    }


  @keyframes float {
    0%   { transform: translateY(0); }
    50%  { transform: translateY(-10px); }
    100% { transform: translateY(0); }
  }

  #aiAssistant {
    width: 55px;
    height: 60px;
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 999;
    cursor: pointer;
    animation: float 3s ease-in-out infinite;
    background: none;      /* ‚úÖ ‡¶ï‡ßã‡¶®‡ßã ‡¶ï‡¶≠‡¶æ‡¶∞/box ‡¶®‡¶æ‡¶á */
    border: none;
    box-shadow: none;      /* ‚úÖ ‡¶ï‡ßã‡¶®‡ßã shadow ‡¶®‡¶æ‡¶á */
    transition: transform 0.3s;
  } 


    #aiAssistant:hover {
      transform: scale(1.1);
    }

    /* Dark Mode */
    body.dark-mode {
      background: #121212;
      color: #f0f0f0;
    }

    body.dark-mode #toolbar {
      background: linear-gradient(180deg, #2c2c2c, #444);
    }

    body.dark-mode select,
    body.dark-mode input,
    body.dark-mode button {
      background-color: #222;
      color: #fff;
    }
  </style>
</head>
<body>

  <div id="toolbar">
    <h2>üìù Whiteboard</h2>
    <button onclick="setTool('pen')">‚úèÔ∏è Pen</button>
    <button onclick="setTool('eraser')">üßΩ Eraser</button>
    <button onclick="setTool('text')">üî§ Text</button>

    <label style="color:white;">Color:</label>
    <select id="colorPicker" onchange="color=this.value;">
      <option value="black">Black</option>
      <option value="white">White</option>
      <option value="purple">Purple</option>
      <option value="blue">Blue</option>
      <option value="cyan">Cyan</option>
      <option value="green">Green</option>
      <option value="lime">Lime</option>
      <option value="yellow">Yellow</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
    </select>

    <label style="color:white;">Font Size:</label>
    <input type="number" id="fontSize" value="20" min="10" max="60"> px

    <label style="color:white;">Background:</label>
    <select id="bgColorPicker" onchange="changeBackground(this.value)">
      <option value="white">White</option>
      <option value="black">Black</option>
      <option value="lightgray">Gray</option>
      <option value="lightblue">Light Blue</option>
      <option value="lightyellow">Light Yellow</option>
      <option value="green">Green</option>
      <option value="purple">Purple</option>
      <option value="cyan">Cyan</option>
      <option value="lime">Lime</option>
      <option value="yellow">Yellow</option>
      <option value="orange">Orange</option>
      <option value="red">Red</option>
    </select>

    <label style="color:white;">Upload Image:</label>
    <input type="file" id="imgUploader" accept="image/*">

    <button onclick="clearCanvas()">üóëÔ∏è Clear Canvas</button>
    <button onclick="saveAsPDF()">üíæ Save as PDF</button>
  </div>

   
   <script>
  async function saveAsPDF() {
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF();

    // Create temporary canvas to match actual canvas
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tempCtx = tempCanvas.getContext("2d");

    // Fill background color
    tempCtx.fillStyle = bgColor;
    tempCtx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw image if any
    if (backgroundImage) {
      tempCtx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
    }

    // Draw texts again
    for (let t of texts) {
      tempCtx.font = `${t.size}px Arial`;
      tempCtx.fillStyle = t.color;
      tempCtx.fillText(t.text, t.x, t.y);
    }

    // Draw original canvas content
    tempCtx.drawImage(canvas, 0, 0);

    const imgData = tempCanvas.toDataURL('image/jpeg', 1.0);
    const imgProps = pdf.getImageProperties(imgData);
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

    pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
    pdf.save("whiteboard.pdf");
  }
</script>


  <canvas id="board"></canvas>

  <!-- ‚úÖ AI Assistant Icon -->
  <img id="aiAssistant" src="panda.png" alt="AI Assistant" />
  <!-- ‚úÖ AI Assistant Icon -->

  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    let tool = 'pen';
    let color = 'black';
    let size = 2;
    let fontSize = 20;
    let drawing = false;
    let startX, startY;
    let texts = [];
    let selectedText = null;
    let bgColor = 'white';
    let backgroundImage = null;

    function resizeCanvas() {
      canvas.width = window.innerWidth - 220;
      canvas.height = window.innerHeight;
      fillBackground();
      redrawTexts();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function fillBackground() {
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if (backgroundImage) {
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
      }
    }

    function changeBackground(newColor) {
      bgColor = newColor;
      fillBackground();
      redrawTexts();
    }

    function setTool(t) { tool = t; }

    function clearCanvas() {
      texts = [];
      backgroundImage = null;
      fillBackground();
    }

    function redrawTexts() {
      for (let t of texts) {
        ctx.font = `${t.size}px Arial`;
        ctx.fillStyle = t.color;
        ctx.fillText(t.text, t.x, t.y);
      }
    }

    canvas.addEventListener('mousedown', (e) => {
      startX = e.offsetX;
      startY = e.offsetY;
      fontSize = document.getElementById('fontSize').value;

      if (tool === 'pen' || tool === 'eraser') {
        drawing = true;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
      }

      if (tool === 'text') {
        selectedText = null;
        for (let t of texts) {
          const width = ctx.measureText(t.text).width;
          const height = parseInt(t.size);
          if (startX >= t.x && startX <= t.x + width && startY <= t.y && startY >= t.y - height) {
            selectedText = t;
            break;
          }
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      if (drawing && (tool === 'pen' || tool === 'eraser')) {
        ctx.strokeStyle = (tool === 'eraser') ? bgColor : color;
        ctx.lineWidth = size;
        ctx.lineTo(e.offsetX, e.offsetY);
        ctx.stroke();
      }

      if (selectedText && tool === 'text') {
        selectedText.x = e.offsetX;
        selectedText.y = e.offsetY;
        fillBackground();
        redrawTexts();
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (drawing) {
        drawing = false;
      }

      if (tool === 'text' && !selectedText) {
        let userText = prompt('Enter text:');
        if (userText) {
          texts.push({ text: userText, x: startX, y: startY, color: color, size: fontSize });
          fillBackground();
          redrawTexts();
        }
      }
      selectedText = null;
    });

    canvas.addEventListener('dblclick', (e) => {
      const x = e.offsetX;
      const y = e.offsetY;
      for (let t of texts) {
        const width = ctx.measureText(t.text).width;
        const height = parseInt(t.size);
        if (x >= t.x && x <= t.x + width && y <= t.y && y >= t.y - height) {
          let newText = prompt('Edit text:', t.text);
          if (newText) {
            t.text = newText;
            fillBackground();
            redrawTexts();
          }
        }
      }
    });

    document.getElementById('imgUploader').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const img = new Image();
      const reader = new FileReader();

      reader.onload = function(event) {
        img.onload = function() {
          backgroundImage = img;
          fillBackground();
          redrawTexts();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // üî• AI Assistant Dark Mode Toggle
    document.getElementById('aiAssistant').addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      if (document.body.classList.contains('dark-mode')) {
        bgColor = '#121212';
      } else {
        bgColor = 'white';
      }
      fillBackground();
      redrawTexts();
    });

    canvas.addEventListener('mouseout', () => { drawing = false; });
  </script>

</body>
</html>